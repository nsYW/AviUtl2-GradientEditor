@MultiGradient
--filter
--label:色調整
--information:Multi Gradient for AviUtl2 v1.0.0 by azurite
--track@intensity:強さ,0,100,100,0.01
--track0:中心X,-5000,5000,0,0.1
--track1:中心Y,-5000,5000,0,0.1
--track@angle:角度,-360,360,0,0.1
--track@radius:幅,0,2000,100,1
--select@gradient_type:形状=0,線形=0,円形=1,短形=2,凸形=3,円形ループ=4,短形ループ=5,凸形ループ=6
--select@blend_mode:合成モード=0,通常=0,加算=1,減算=2,乗算=3,スクリーン=4,オーバーレイ=5,比較(明)=6
--check@is_fit:幅をオブジェクトに合わせる,0
--group:色,false
--color@col1:色1,0x000000
--color@col2:色2,0xffffff
--color@col3:色3,0xffffff
--color@col4:色4,0xffffff
--color@col5:色5,0xffffff
--color@col6:色6,0xffffff
--color@col7:色7,0xffffff
--color@col8:色8,0xffffff
--color@col9:色9,0xffffff
--color@col10:色10,0xffffff
--color@col11:色11,0xffffff
--color@col12:色12,0xffffff
--color@col13:色13,0xffffff
--color@col14:色14,0xffffff
--color@col15:色15,0xffffff
--color@col16:色16,0xffffff
--color@col17:色17,0xffffff
--color@col18:色18,0xffffff
--color@col19:色19,0xffffff
--color@col20:色20,0xffffff
--color@col21:色21,0xffffff
--color@col22:色22,0xffffff
--color@col23:色23,0xffffff
--color@col24:色24,0xffffff
--color@col25:色25,0xffffff
--color@col26:色26,0xffffff
--color@col27:色27,0xffffff
--color@col28:色28,0xffffff
--color@col29:色29,0xffffff
--color@col30:色30,0xffffff
--group
--group:透明度,false
--track@alpha1:透明度1,0,100,0,0.01
--track@alpha2:透明度2,0,100,0,0.01
--track@alpha3:透明度3,0,100,0,0.01
--track@alpha4:透明度4,0,100,0,0.01
--track@alpha5:透明度5,0,100,0,0.01
--track@alpha6:透明度6,0,100,0,0.01
--track@alpha7:透明度7,0,100,0,0.01
--track@alpha8:透明度8,0,100,0,0.01
--track@alpha9:透明度9,0,100,0,0.01
--track@alpha10:透明度10,0,100,0,0.01
--track@alpha11:透明度11,0,100,0,0.01
--track@alpha12:透明度12,0,100,0,0.01
--track@alpha13:透明度13,0,100,0,0.01
--track@alpha14:透明度14,0,100,0,0.01
--track@alpha15:透明度15,0,100,0,0.01
--track@alpha16:透明度16,0,100,0,0.01
--track@alpha17:透明度17,0,100,0,0.01
--track@alpha18:透明度18,0,100,0,0.01
--track@alpha19:透明度19,0,100,0,0.01
--track@alpha20:透明度20,0,100,0,0.01
--track@alpha21:透明度21,0,100,0,0.01
--track@alpha22:透明度22,0,100,0,0.01
--track@alpha23:透明度23,0,100,0,0.01
--track@alpha24:透明度24,0,100,0,0.01
--track@alpha25:透明度25,0,100,0,0.01
--track@alpha26:透明度26,0,100,0,0.01
--track@alpha27:透明度27,0,100,0,0.01
--track@alpha28:透明度28,0,100,0,0.01
--track@alpha29:透明度29,0,100,0,0.01
--track@alpha30:透明度30,0,100,0,0.01
--group
--group:位置,false
--track@pos1:位置1,0,100,0,0.01
--track@pos2:位置2,0,100,100,0.01
--track@pos3:位置3,0,100,0,0.01
--track@pos4:位置4,0,100,0,0.01
--track@pos5:位置5,0,100,0,0.01
--track@pos6:位置6,0,100,0,0.01
--track@pos7:位置7,0,100,0,0.01
--track@pos8:位置8,0,100,0,0.01
--track@pos9:位置9,0,100,0,0.01
--track@pos10:位置10,0,100,0,0.01
--track@pos11:位置11,0,100,0,0.01
--track@pos12:位置12,0,100,0,0.01
--track@pos13:位置13,0,100,0,0.01
--track@pos14:位置14,0,100,0,0.01
--track@pos15:位置15,0,100,0,0.01
--track@pos16:位置16,0,100,0,0.01
--track@pos17:位置17,0,100,0,0.01
--track@pos18:位置18,0,100,0,0.01
--track@pos19:位置19,0,100,0,0.01
--track@pos20:位置20,0,100,0,0.01
--track@pos21:位置21,0,100,0,0.01
--track@pos22:位置22,0,100,0,0.01
--track@pos23:位置23,0,100,0,0.01
--track@pos24:位置24,0,100,0,0.01
--track@pos25:位置25,0,100,0,0.01
--track@pos26:位置26,0,100,0,0.01
--track@pos27:位置27,0,100,0,0.01
--track@pos28:位置28,0,100,0,0.01
--track@pos29:位置29,0,100,0,0.01
--track@pos30:位置30,0,100,0,0.01
--group
--group:中間点,false
--track@midpoint1:中間点1,0,100,50,0.01
--track@midpoint2:中間点2,0,100,50,0.01
--track@midpoint3:中間点3,0,100,50,0.01
--track@midpoint4:中間点4,0,100,50,0.01
--track@midpoint5:中間点5,0,100,50,0.01
--track@midpoint6:中間点6,0,100,50,0.01
--track@midpoint7:中間点7,0,100,50,0.01
--track@midpoint8:中間点8,0,100,50,0.01
--track@midpoint9:中間点9,0,100,50,0.01
--track@midpoint10:中間点10,0,100,50,0.01
--track@midpoint11:中間点11,0,100,50,0.01
--track@midpoint12:中間点12,0,100,50,0.01
--track@midpoint13:中間点13,0,100,50,0.01
--track@midpoint14:中間点14,0,100,50,0.01
--track@midpoint15:中間点15,0,100,50,0.01
--track@midpoint16:中間点16,0,100,50,0.01
--track@midpoint17:中間点17,0,100,50,0.01
--track@midpoint18:中間点18,0,100,50,0.01
--track@midpoint19:中間点19,0,100,50,0.01
--track@midpoint20:中間点20,0,100,50,0.01
--track@midpoint21:中間点21,0,100,50,0.01
--track@midpoint22:中間点22,0,100,50,0.01
--track@midpoint23:中間点23,0,100,50,0.01
--track@midpoint24:中間点24,0,100,50,0.01
--track@midpoint25:中間点25,0,100,50,0.01
--track@midpoint26:中間点26,0,100,50,0.01
--track@midpoint27:中間点27,0,100,50,0.01
--track@midpoint28:中間点28,0,100,50,0.01
--track@midpoint29:中間点29,0,100,50,0.01
--group
--group:その他,false
--track@blur_width:ぼかし幅,0,100,100,1
--select@color_space:色空間=0,sRGB=0,Linear sRGB=1,HSV=2,HSL=3,L*a*b=4,LCh=5,Oklab=6,Oklch=7
--select@interp_dir:補間経路=0,短経路=0,長経路=1
--track@marker_num:マーカー数,2,30,2,1
--group

--[[pixelshader@psmain:
#define PI 3.14159265358979323846
#define TAU (2.0 * PI)

#define SATURATION_THRESHOLD 0
#define CHROMA_THRESHOLD 0.02  // 無彩色か判定するのに使う誤差を考慮した閾値

static const float3 D65_WHITE = float3(0.95047, 1.0, 1.08883);
static const float3 D50_WHITE = float3(0.96422, 1.0, 0.82521);

float mod(float x, float y) {
    return x - y * floor(x / y);
}

float alpha_mix(float alpha1, float alpha2, float t) {
    return clamp(lerp(alpha1, alpha2, t), 0.0, 1.0);
}

// ----------------------------------------------------------------------------
// linear sRGB
// ----------------------------------------------------------------------------
// 参考: https://w.wiki/DBwx
float gamma_decode(float x) {
    return x <= 0.04045 ? x / 12.92 : pow(abs((x + 0.055) / 1.055), 2.4);
}

float3 srgb2linear(float3 x) {
    return float3(gamma_decode(x.r), gamma_decode(x.g), gamma_decode(x.b));
    //return pow(abs(x), float3(2.2));  // 近似
}

// 参考: https://w.wiki/DBx3
float gamma_encode(float x) {
    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(abs(x), 1.0 / 2.4) - 0.055;
}

float3 linear2srgb(float3 x) {
    return float3(gamma_encode(x.r), gamma_encode(x.g), gamma_encode(x.b));
    //return pow(abs(x), float3(1.0 / 2.2));  // 近似
}

// ----------------------------------------------------------------------------
// HSV
// ----------------------------------------------------------------------------
// 参考: https://w.wiki/DD6A
float3 srgb2hsv(float3 rgb) {
    float max_val = max(rgb.r, max(rgb.g, rgb.b));
    float min_val = min(rgb.r, min(rgb.g, rgb.b));
    float chroma = max_val - min_val;

    float hue = 0;
    float saturation = 0;

    if (chroma == 0) hue = 0;
    else if (max_val == rgb.r) hue = mod((rgb.g - rgb.b) / chroma, 6.0);
    else if (max_val == rgb.g) hue = (rgb.b - rgb.r) / chroma + 2.0;
    else hue = (rgb.r - rgb.g) / chroma + 4.0;
    hue *= 60.0;

    if (max_val == 0) saturation = 0;
    else saturation = chroma / max_val;

    return float3(radians(hue), saturation, max_val);
}

// 参考: https://w.wiki/DD66
float hsv2srgb_f(float3 hsv, float n) {
    float k = mod((n + degrees(hsv.x) / 60.0), 6.0);
    return hsv.z - hsv.z * hsv.y * max(0.0, min(k, min(4.0 - k, 1.0)));
}
float3 hsv2srgb(float3 hsv) {
    return float3(
        hsv2srgb_f(hsv, 5.0),
        hsv2srgb_f(hsv, 3.0),
        hsv2srgb_f(hsv, 1.0)
    );
}

// ----------------------------------------------------------------------------
// HSL
// ----------------------------------------------------------------------------
// 参考: https://w.wiki/DD6A
float3 srgb2hsl(float3 rgb) {
    float max_val = max(rgb.r, max(rgb.g, rgb.b));
    float min_val = min(rgb.r, min(rgb.g, rgb.b));
    float chroma = max_val - min_val;

    float hue = 0;
    if (chroma == 0) hue = 0;
    else if (max_val == rgb.r) hue = mod((rgb.g - rgb.b) / chroma, 6.0);
    else if (max_val == rgb.g) hue = (rgb.b - rgb.r) / chroma + 2.0;
    else hue = (rgb.r - rgb.g) / chroma + 4.0;
    hue *= 60.0;

    float lightness = (max_val + min_val) / 2.0;

    float saturation = 0.0;
    if (lightness != 1.0 && lightness != 0.0) {
        saturation = chroma / (1.0 - abs(2.0 * lightness - 1.0));
    }
    return float3 (radians(hue), saturation, lightness);
}

// 参考: https://w.wiki/DD6D
float hsl2rgb_f(float3 hsl, float n) {
    float k = mod((n + degrees(hsl.x) / 30.0), 12.0);
    float a = hsl.y * min(hsl.z, 1.0 - hsl.z);
    return hsl.z - a * max(-1.0, min(k - 3.0, min(9.0 - k, 1.0)));
}

float3 hsl2srgb(float3 hsl) {
    return float3(
        hsl2rgb_f(hsl, 0.0),
        hsl2rgb_f(hsl, 8.0),
        hsl2rgb_f(hsl, 4.0)
    );
}

float hue_mix(float hue1, float hue2, float t, int interp_dir) {
    float diff = hue2 - hue1;
    switch (interp_dir) {
    case 0:
        if (diff > PI) hue1 += TAU;
        else if (diff < -PI) hue2 += TAU;
        break;
    case 1:
        if (0.0 < diff && diff < PI) hue1 += TAU;
        else if (-PI < diff && diff <= 0.0) hue2 += TAU;
        break;
    }
    float angle = lerp(hue1, hue2, t);
    return mod(mod(angle, TAU) + TAU, TAU);
}

// 各色が無彩色かどうかに基づいてHueを調整し混合する
float adjust_and_mix_hue(float h1, float h2, bool has_valid_hue1, bool has_valid_hue2, float t, int interp_dir) {
    if (has_valid_hue1 && !has_valid_hue2) {
        h2 = h1;
    } else if (!has_valid_hue1 && has_valid_hue2) {
        h1 = h2;
    } else if (!has_valid_hue1 && !has_valid_hue2) {
        h1 = 0.0;
        h2 = 0.0;
    }
    return hue_mix(h1, h2, t, interp_dir);
}

// HSLも同じ補間を行う
float3 hsv_mix(float3 a, float3 b, float x, int interp_dir) {
    bool has_valid_hue1 = a.y > SATURATION_THRESHOLD;
    bool has_valid_hue2 = b.y > SATURATION_THRESHOLD;
    float hue = adjust_and_mix_hue(a.x, b.x, has_valid_hue1, has_valid_hue2, x, interp_dir);
    float3 hsv = float3(hue, lerp(a.yz, b.yz, x));
    return hsv;
}

// ----------------------------------------------------------------------------
// XYZ
// ----------------------------------------------------------------------------
// 参考: http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html
float3 linear2d50xyz(float3 linear_rgb) {
    float x = (0.4360747 * linear_rgb.r + 0.3850649 * linear_rgb.g + 0.1430804 * linear_rgb.b);
    float y = (0.2225045 * linear_rgb.r + 0.7168786 * linear_rgb.g + 0.0606169 * linear_rgb.b);
    float z = (0.0139322 * linear_rgb.r + 0.0971045 * linear_rgb.g + 0.7141733 * linear_rgb.b);
    return float3(x, y, z);
}

float3 d50xyz2linear(float3 xyz) {
    float r = (xyz.x *  3.1338561 + xyz.y * -1.6168667 + xyz.z * -0.4906146);
    float g = (xyz.x * -0.9787684 + xyz.y *  1.9161415 + xyz.z *  0.0334540);
    float b = (xyz.x *  0.0719453 + xyz.y * -0.2289914 + xyz.z *  1.4052427);
    return float3(r, g, b);
}

float3 linear2d65xyz(float3 linear_rgb) {
    float x = (0.4124564 * linear_rgb.r + 0.3575761 * linear_rgb.g + 0.1804375 * linear_rgb.b);
    float y = (0.2126729 * linear_rgb.r + 0.7151522 * linear_rgb.g + 0.0721750 * linear_rgb.b);
    float z = (0.0193339 * linear_rgb.r + 0.1191920 * linear_rgb.g + 0.9503041 * linear_rgb.b);
    return float3(x, y, z);
}

float3 d65xyz2linear(float3 xyz) {
    float r = (xyz.x *  3.2404542 + xyz.y * -1.5371385 + xyz.z * -0.4985314);
    float g = (xyz.x * -0.9692660 + xyz.y *  1.8760108 + xyz.z *  0.0415560);
    float b = (xyz.x *  0.0556434 + xyz.y * -0.2040259 + xyz.z *  1.0572252);
    return float3(r, g, b);
}

// ----------------------------------------------------------------------------
// CIELAB
// ----------------------------------------------------------------------------
// 参考: http://www.brucelindbloom.com/Eqn_XYZ_to_Lab.html
float xyz2lab_f(float x) {
    return x > 0.008856 ? pow(abs(x), 0.333333333) : (903.3 * x + 16.0) / 116.0;
}

float3 d50xyz2lab(float3 xyz) {
    float3 xyz_scaled = xyz / D50_WHITE;
    xyz_scaled = float3(
        xyz2lab_f(xyz_scaled.x),
        xyz2lab_f(xyz_scaled.y),
        xyz2lab_f(xyz_scaled.z)
    );
    return float3(
        (116.0 * xyz_scaled.y) - 16.0,
         500.0 * (xyz_scaled.x - xyz_scaled.y),
         200.0 * (xyz_scaled.y - xyz_scaled.z)
    );
}

float3 d65xyz2lab(float3 xyz) {
    float3 xyz_scaled = xyz / D65_WHITE;
    xyz_scaled = float3(
        xyz2lab_f(xyz_scaled.x),
        xyz2lab_f(xyz_scaled.y),
        xyz2lab_f(xyz_scaled.z)
    );
    return float3(
        (116.0 * xyz_scaled.y) - 16.0,
         500.0 * (xyz_scaled.x - xyz_scaled.y),
         200.0 * (xyz_scaled.y - xyz_scaled.z)
    );
}

// 参考: http://www.brucelindbloom.com/Eqn_Lab_to_XYZ.html
float lab2xyz_f(float x) {
    return pow(abs(x), 3.0) > 0.008856 ? pow(abs(x), 3.0) : (116.0 * x - 16.0) / 903.3;
}

float3 lab2d50xyz(float3 lab) {
    float f = (lab.x + 16.0) / 116.0;
    float y = lab.x > 0.008856 * 903.3 ? pow(abs((lab.x + 16.0) / 116.0), 3.0) : lab.x / 903.3;
    return D50_WHITE * float3(
        lab2xyz_f(f + lab.y / 500.0),
        y,
        lab2xyz_f(f - lab.z / 200.0)
    );
}

float3 lab2d65xyz(float3 lab) {
    float f = (lab.x + 16.0) / 116.0;
    float y = lab.x > 0.008856 * 903.3 ? pow(abs((lab.x + 16.0) / 116.0), 3.0) : lab.x / 903.3;
    return D65_WHITE * float3(
        lab2xyz_f(f + lab.y / 500.0),
        y,
        lab2xyz_f(f - lab.z / 200.0)
    );
}

float3 linear2d50lab(float3 linear_rgb) {
    float3 xyz = linear2d50xyz(linear_rgb);
    return d50xyz2lab(xyz);
}

float3 d50lab2linear(float3 lab) {
    float3 xyz = lab2d50xyz(lab);
    return d50xyz2linear(xyz);
}

float3 linear2d65lab(float3 linear_rgb) {
    float3 xyz = linear2d65xyz(linear_rgb);
    return d65xyz2lab(xyz);
}

float3 d65lab2linear(float3 lab) {
    float3 xyz = lab2d65xyz(lab);
    return d65xyz2linear(xyz);
}

// ----------------------------------------------------------------------------
// CIELCH
// ----------------------------------------------------------------------------
// 参考: http://www.brucelindbloom.com/Eqn_Lab_to_LCH.html
float3 lab2lch(float3 lab) {
    float chroma = length(float2(lab.y, lab.z));
    float hue = 0.0;
    // 無彩色でない場合のみHueを計算
    if (chroma > CHROMA_THRESHOLD) {
        hue = atan2(lab.z, lab.y);
        hue = hue < 0.0 ? hue + TAU : hue;
    }
    return float3(
        lab.x,
        chroma,
        hue
    );
}

// 参考: http://www.brucelindbloom.com/Eqn_LCH_to_Lab.html
float3 lch2lab(float3 lch) {
    return float3(
        lch.x,
        lch.y * cos(lch.z),
        lch.y * sin(lch.z)
    );
}

float3 linear2d50lch(in float3 linear_rgb) {
    float3 xyz = linear2d50xyz(linear_rgb);
    float3 lab = d50xyz2lab(xyz);
    return lab2lch(lab);
}

float3 d50lch2linear(in float3 lch) {
    float3 lab = lch2lab(lch);
    float3 xyz = lab2d50xyz(lab);
    return d50xyz2linear(xyz);
}

float3 linear2d65lch(in float3 linear_rgb) {
    float3 xyz = linear2d65xyz(linear_rgb);
    float3 lab = d65xyz2lab(xyz);
    return lab2lch(lab);
}

float3 d65lch2linear(in float3 lch) {
    float3 lab = lch2lab(lch);
    float3 xyz = lab2d65xyz(lab);
    return d65xyz2linear(xyz);
}

float3 lch_mix(float3 a, float3 b, float x, int interp_dir) {
    float lightness = lerp(a.x, b.x, x);
    float chroma = lerp(a.y, b.y, x);
    bool has_valid_hue1 = a.y > CHROMA_THRESHOLD;
    bool has_valid_hue2 = b.y > CHROMA_THRESHOLD;
    float hue = adjust_and_mix_hue(a.z, b.z, has_valid_hue1, has_valid_hue2, x, interp_dir);
    lightness = clamp(lightness, 0.0, 100.0);
    chroma = max(chroma, 0.0);
    return float3(lightness, chroma, hue);
}

// ----------------------------------------------------------------------------
// Oklab
// ----------------------------------------------------------------------------
float cbrt(float x) {
    return sign(x) * pow(abs(x), 1.0 / 3.0);
}

// 参考: https://bottosson.github.io/posts/oklab/#converting-from-linear-srgb-to-oklab
float3 linear2oklab(float3 linear_rgb) {
    float l = 0.4122214708 * linear_rgb.r + 0.5363325363 * linear_rgb.g + 0.0514459929 * linear_rgb.b;
	float m = 0.2119034982 * linear_rgb.r + 0.6806995451 * linear_rgb.g + 0.1073969566 * linear_rgb.b;
	float s = 0.0883024619 * linear_rgb.r + 0.2817188376 * linear_rgb.g + 0.6299787005 * linear_rgb.b;

    float l_ = cbrt(l);
    float m_ = cbrt(m);
    float s_ = cbrt(s);

    return float3(
        0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
        1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
        0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
    );
}

// 参考: https://bottosson.github.io/posts/oklab/#converting-from-linear-srgb-to-oklab
float3 oklab2linear(float3 oklab) {
    float l_ = oklab.x + 0.3963377774 * oklab.y + 0.2158037573 * oklab.z;
    float m_ = oklab.x - 0.1055613458 * oklab.y - 0.0638541728 * oklab.z;
    float s_ = oklab.x - 0.0894841775 * oklab.y - 1.2914855480 * oklab.z;

    float l = l_ * l_ * l_;
    float m = m_ * m_ * m_;
    float s = s_ * s_ * s_;

    return float3(
		 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
		-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
		-0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
    );
}

// ----------------------------------------------------------------------------
// Oklch
// ----------------------------------------------------------------------------
float3 linear2oklch(float3 linear_rgb) {
    float3 oklab = linear2oklab(linear_rgb);
    return lab2lch(oklab);
}

float3 oklch2linear(float3 oklch) {
    float3 oklab = lch2lab(oklch);
    return oklab2linear(oklab);
}
Texture2D<float4> src : register(t0);
SamplerState samp : register(s0);

static const int GRADIENT_MAX_COUNT = 30;
cbuffer constant0 : register(b0) {
    float2 resolution;
    float2 center;
    float radius;
    float gradient_type;
    float is_fit;
    float pad1;
    float2x2 angle;
    float2 pad2;
    float color_space;
    float interp_dir;
    float gradient_w;
    float gradient_count;  // 実際のグラデーションの数
    float4 start_col[GRADIENT_MAX_COUNT];
    float4 stop_col[GRADIENT_MAX_COUNT];
    float4 pos_and_mid[GRADIENT_MAX_COUNT];
}

float4 blend_colors(float4 color1, float4 color2, float t, float color_space, int interp_dir)
{
    float3 col1 = color1.rgb;
    float3 col2 = color2.rgb;
    float alpha1 = color1.a;
    float alpha2 = color2.a;
    float3 result = float3(0.0, 0.0, 0.0);
    float mixed_alpha = max(alpha_mix(alpha1, alpha2, t), 1e-6);
    switch (color_space) {
        case 0:  // sRGB
        {
            float3 premulti_srgb1 = col1 * alpha1;
            float3 premulti_srgb2 = col2 * alpha2;
            float3 mixed_srgb = lerp(premulti_srgb1, premulti_srgb2, t);
            float3 unpremulti_srgb = mixed_srgb / mixed_alpha;
            result = unpremulti_srgb;
            break;
        }
        case 1:  // Linear sRGB
        {
            float3 premulti_linear1 = srgb2linear(col1) * alpha1;
            float3 premulti_linear2 = srgb2linear(col2) * alpha2;
            float3 mixed_linear = lerp(premulti_linear1, premulti_linear2, t);
            float3 unpremulti_linear = mixed_linear / mixed_alpha;
            result = linear2srgb(clamp(unpremulti_linear, 0.0, 1.0));
            break;
        }
        case 2:  // HSV
        {
            float3 hsv1 = srgb2hsv(col1);
            float3 hsv2 = srgb2hsv(col2);

            // 片方が透明であってもその色が持っているHueを維持してグラデーションを作るために、
            // アルファを掛ける前の彩度で無彩色かどうかを判定する
            bool has_valid_hue1 = hsv1.y > SATURATION_THRESHOLD;
            bool has_valid_hue2 = hsv2.y > SATURATION_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(hsv1.x, hsv2.x, has_valid_hue1, has_valid_hue2, t, interp_dir);

            // 彩度と明度はアルファを掛けた後で補間する
            float2 sv1 = hsv1.yz * alpha1;
            float2 sv2 = hsv2.yz * alpha2;
            float2 mixed_sv = lerp(sv1, sv2, t);
            mixed_sv /= mixed_alpha;

            // 結果の色を合成
            float3 result_hsv = float3(mixed_hue, mixed_sv);
            result = hsv2srgb(result_hsv);
            break;
        }
        case 3:  // HSL
        {
            float3 hsl1 = srgb2hsl(col1);
            float3 hsl2 = srgb2hsl(col2);

            bool has_valid_hue1 = hsl1.y > SATURATION_THRESHOLD;
            bool has_valid_hue2 = hsl2.y > SATURATION_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(hsl1.x, hsl2.x, has_valid_hue1, has_valid_hue2, t, interp_dir);

            float2 sl1 = hsl1.yz * alpha1;
            float2 sl2 = hsl2.yz * alpha2;
            float2 mixed_sl = lerp(sl1, sl2, t);
            mixed_sl /= mixed_alpha;

            float3 result_hsl = float3(mixed_hue, mixed_sl);
            result = hsl2srgb(result_hsl);
            break;
        }
        case 4:  // L*a*b* (CIELAB)
        {
            // D50基準
            float3 lab1 = linear2d50lab(srgb2linear(col1));
            float3 lab2 = linear2d50lab(srgb2linear(col2));
            float3 premulti_lab1 = lab1 * alpha1;
            float3 premulti_lab2 = lab2 * alpha2;
            float3 mixed_lab = lerp(premulti_lab1, premulti_lab2, t);
            float3 unpremulti_lab = mixed_lab / mixed_alpha;
            result = linear2srgb(clamp(d50lab2linear(unpremulti_lab), 0.0, 1.0));
            break;
        }
        case 5:  // LCh
        {
            // D50基準
            float3 lch1 = linear2d50lch(srgb2linear(col1));
            float3 lch2 = linear2d50lch(srgb2linear(col2));

            bool has_valid_hue1 = lch1.y > CHROMA_THRESHOLD;
            bool has_valid_hue2 = lch2.y > CHROMA_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(lch1.z, lch2.z, has_valid_hue1, has_valid_hue2, t, interp_dir);

            float2 lc1 = lch1.xy * alpha1;
            float2 lc2 = lch2.xy * alpha2;
            float2 mixed_lc = lerp(lc1, lc2, t);
            mixed_lc = mixed_lc / mixed_alpha;

            mixed_lc.x = clamp(mixed_lc.x, 0.0, 100.0);
            mixed_lc.y = max(mixed_lc.y, 0.0);

            float3 result_lch = float3(mixed_lc.x, mixed_lc.y, mixed_hue);
            result = linear2srgb(clamp(d50lch2linear(result_lch), 0.0, 1.0));
            break;
        }
        case 6:  // Oklab
        {
            float3 oklab1 = linear2oklab(srgb2linear(col1));
            float3 oklab2 = linear2oklab(srgb2linear(col2));
            float3 premulti_oklab1 = oklab1 * alpha1;
            float3 premulti_oklab2 = oklab2 * alpha2;
            float3 mixed_oklab = lerp(premulti_oklab1, premulti_oklab2, t);
            float3 unpremulti_oklab = mixed_oklab / mixed_alpha;
            result = linear2srgb(clamp(oklab2linear(unpremulti_oklab), 0.0, 1.0));
            break;
        }
        case 7:  // OkLCh
        {
            float3 oklch1 = linear2oklch(srgb2linear(col1));
            float3 oklch2 = linear2oklch(srgb2linear(col2));

            bool has_valid_hue1 = oklch1.y > CHROMA_THRESHOLD;
            bool has_valid_hue2 = oklch2.y > CHROMA_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(oklch1.z, oklch2.z, has_valid_hue1, has_valid_hue2, t, interp_dir);

            float2 lc1 = oklch1.xy * alpha1;
            float2 lc2 = oklch2.xy * alpha2;
            float2 mixed_lc = lerp(lc1, lc2, t);
            mixed_lc = mixed_lc / mixed_alpha;

            mixed_lc.x = clamp(mixed_lc.x, 0.0, 1.0);
            mixed_lc.y = max(mixed_lc.y, 0.0);

            float3 result_oklch = float3(mixed_lc.x, mixed_lc.y, mixed_hue);
            result = linear2srgb(clamp(oklch2linear(result_oklch), 0.0, 1.0));
            break;
        }
    }
    return float4(result * mixed_alpha, mixed_alpha);
}

float4 makeGradient(float4 col1, float4 col2, float t, float mid, float width, float color_space, int interp_dir)
{
    float half_width = width * 0.5;

    float lower = mid - half_width;
    float upper = mid + half_width;

    t = smoothstep(lower, upper, t);

    float4 result = blend_colors(col1, col2, t, color_space, interp_dir);
    return result;
}

float4 psmain(float4 pos : SV_Position, float2 uv : TEXCOORD) : SV_Target {
    int safe_count = min(gradient_count, GRADIENT_MAX_COUNT);
    if (safe_count <= 0) return float4(1, 1, 1, 1);

    float x = 1.0;

    // 画面の長辺または短辺で正規化
    float aspect = max(resolution.x, resolution.y);

    // 中心からの相対座標
    float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / aspect;

    switch (gradient_type) {
        case 0: // 線形
        {
            if (is_fit <= 0) {
                float2 st = (pos.xy - center) / resolution.y;
                float scale = radius / resolution.y;
                st -= (resolution.xy / (resolution.y * 2.0));
                st = mul(angle, st);
                st += (resolution.xy / (resolution.y * 2.0));
                x = (st.y - 0.5) / scale + 0.5;
            } else {
                // 4隅の絶対座標
                float2 c0 = float2(0.0, 0.0);
                float2 c1 = float2(resolution.x, 0.0);
                float2 c2 = float2(0.0, resolution.y);
                float2 c3 = resolution.xy;

                // 回転後の軸への投影
                float y0 = mul(angle, c0).y;
                float y1 = mul(angle, c1).y;
                float y2 = mul(angle, c2).y;
                float y3 = mul(angle, c3).y;

                float min_y = min(min(y0, y1), min(y2, y3));
                float max_y = max(max(y0, y1), max(y2, y3));

                float py = mul(angle, (pos.xy - center)).y;
                x = (py - min_y) / max(max_y - min_y, 1e-6);
            }
            break;
        }
        case 1: // 円形
        {
            float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / max(resolution.x, resolution.y);
            float scale = (is_fit <= 0) ? radius / max(resolution.x, resolution.y) : min(resolution.x, resolution.y) / max(resolution.x, resolution.y);
            st = mul(angle, st);
            x = length(st) / max(scale * 2.0, 1e-6);
            break;
        }
        case 2: // 短形
        {
            float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / max(resolution.x, resolution.y);
            float scale = (is_fit <= 0) ? radius / max(resolution.x, resolution.y) : min(resolution.x, resolution.y) / max(resolution.x, resolution.y);
            st = mul(angle, st);
            x = (abs(st.x) + abs(st.y)) / max(scale * 2.0, 1e-6);
            break;
        }
        case 3:  // 凸形
        {
            if (is_fit <= 0) {
                float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / max(resolution.x, resolution.y);
                float scale = radius / max(resolution.x, resolution.y);
                st = mul(angle, st);
                x = abs(st.y) / max(scale * 2.0, 1e-6);
                break;
            } else {
                // 4隅の絶対座標
                float2 c0 = float2(0.0, 0.0);
                float2 c1 = float2(resolution.x, 0.0);
                float2 c2 = float2(0.0, resolution.y);
                float2 c3 = resolution.xy;

                // 回転後の軸への投影
                float y0 = mul(angle, c0).y;
                float y1 = mul(angle, c1).y;
                float y2 = mul(angle, c2).y;
                float y3 = mul(angle, c3).y;

                float min_y = min(min(y0, y1), min(y2, y3));
                float max_y = max(max(y0, y1), max(y2, y3));

                float py = mul(angle, (pos.xy - center)).y;
                float t = (py - min_y) / max(max_y - min_y, 1e-6);
                x = abs(t * 2.0 - 1.0);
                break;
            }
        }
        case 4: // 円形ループ
        {
            float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / max(resolution.x, resolution.y);
            // ループ形状では radius が 0 だとモアレがあまりきれいではないので最低でも 1 にする
            float scale = max(radius, 1.0) / max(resolution.x, resolution.y);
            st = mul(angle, st);
            float w = length(st) / max(scale * 2.0, 1e-6);
            float saw = fmod(w, 2.0);
            x = 1.0 - abs(1.0 - saw);
            break;
        }
        case 5: // 短形ループ
        {
            float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / max(resolution.x, resolution.y);
            float scale = max(radius, 1.0) / max(resolution.x, resolution.y);
            st = mul(angle, st);
            float w = (abs(st.x) + abs(st.y)) / max(scale * 2.0, 1e-6);
            float saw = fmod(w, 2.0);
            x = 1.0 - abs(1.0 - saw);
            break;
        }
        case 6: // 凸形ループ
        {
            float2 st = ((pos.xy - center) * 2.0 - resolution.xy) / max(resolution.x, resolution.y);
            float scale = max(radius, 1.0) / max(resolution.x, resolution.y);
            st = mul(angle, st);
            float w = st.y / max(scale * 2.0, 1e-6);
            float saw = w - 2.0 * floor(w / 2.0);  // mod(w, 2.0)
            x = 1.0 - abs(1.0 - saw);
            break;
        }
        default:  // 線形
        {
            float2 st = (pos.xy - center) / resolution.y;
            float scale = radius / resolution.y;
            st -= (resolution.xy / (resolution.y * 2.0));
            st = mul(angle, st);
            st += (resolution.xy / (resolution.y * 2.0));
            x = (st.y - 0.5) / scale + 0.5;
            break;
        }
    }

    x = 1.0 - x;
    float4 out_col = (x <= pos_and_mid[0].x) ? start_col[0] : start_col[safe_count - 1];
    out_col.rgb *= out_col.a;
    x = saturate(x);

    for (int i = 0; i < safe_count; i++) {
        float p_curr = pos_and_mid[i].x;
        float p_next = pos_and_mid[i].y;

        // x が現在の区間内にある場合
        if (x >= p_curr && x < p_next) {
            float dist = p_next - p_curr;

            float t = (x - p_curr) / dist;

            out_col = makeGradient(start_col[i], stop_col[i], t, pos_and_mid[i].z, gradient_w, color_space, interp_dir);
            break;
        }
    }

    return out_col;
}

]]

--[[pixelshader@mask:
Texture2D<float4> src : register(t0);
float4 mask(float4 pos : SV_Position) : SV_Target {
    return src.Load(int3(pos.xy, 0));
}
]]

local colors = {col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11, col12, col13, col14, col15, col16, col17, col18, col19, col20, col21, col22, col23, col24, col25, col26, col27, col28, col29, col30}
local alphas = {alpha1, alpha2, alpha3, alpha4, alpha5, alpha6, alpha7, alpha8, alpha9, alpha10, alpha11, alpha12, alpha13, alpha14, alpha15, alpha16, alpha17, alpha18, alpha19, alpha20, alpha21, alpha22, alpha23, alpha24, alpha25, alpha26, alpha27, alpha28, alpha29, alpha30}
local positions = {pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9, pos10, pos11, pos12, pos13, pos14, pos15, pos16, pos17, pos18, pos19, pos20, pos21, pos22, pos23, pos24, pos25, pos26, pos27, pos28, pos29, pos30}
local midpoints = {midpoint1, midpoint2, midpoint3, midpoint4, midpoint5, midpoint6, midpoint7, midpoint8, midpoint9, midpoint10, midpoint11, midpoint12, midpoint13, midpoint14, midpoint15, midpoint16, midpoint17, midpoint18, midpoint19, midpoint20, midpoint21, midpoint22, midpoint23, midpoint24, midpoint25, midpoint26, midpoint27, midpoint28, midpoint29, 0}

-- 色を正規化する
local function norm_color(color)
    local r, g, b = RGB(color)
    return {r / 255, g / 255, b / 255}
end

-- 非シーケンス、nil以外の値を渡された順番で1つのシーケンスにマージして返す
local function merge(...)
	local function flatten(v, res)
	    res = res or {}
	    if type(v) ~= "table" then
            res[#res + 1] = v
            return res
        end
	    for _, x in ipairs(v) do
            flatten(x, res)
        end
	    return res
	end
	local t = {...}
	return flatten(t)
end

-- テーブルの後ろ側に任意の長さだけ拡張する
local function extend_back(t, n, v)
	if type(v) == "nil" or type(v) == "table" then
		return
	end
	for i = 1, n do
		t[#t + 1] = v
	end
	return t
end

-- テーブルから指定した範囲を切り出す
local function slice(t, first, last)
    local res = {}
    for i = first, last do
        res[#res + 1] = t[i]
    end
    return res
end

-- 並び替え
local function reorder(t, idx)
    local r = {}
    for i, j in ipairs(idx) do
        r[i] = t[j]
    end
    return r
end

-- HLSL のコンスタントバッファーに渡すために変数を詰める
local function pack(colors, alphas, positions, midpoints, color_space, interp_dir, blur_width, marker_num)
    assert(#colors == #alphas and #alphas == #positions and #positions == #midpoints, "Marker arrays must have the same length")

    local marker_count = marker_num
    local MARKER_MAX_COUNT = #colors

    -- マーカー数分だけ切り出す
    local marker_colors = slice(colors, 1, marker_count)
    local marker_alphas = slice(alphas, 1, marker_count)
    local marker_positions = slice(positions, 1, marker_count)
    local marker_midpoints = slice(midpoints, 1, marker_count)

    -- インデックス配列
    local idx = {}
    for i = 1, marker_count do
        idx[i] = i
    end

    table.sort(idx, function(a, b)
        local pa, pb = marker_positions[a], marker_positions[b]
        if pa ~= pb then
            return pa < pb
        end
        return a < b   -- 同じ positions の場合は若いインデックス優先
    end)

    -- 並び替え
    marker_colors   = reorder(marker_colors, idx)
    marker_alphas   = reorder(marker_alphas, idx)
    marker_positions = reorder(marker_positions, idx)
    marker_midpoints = reorder(marker_midpoints, idx)

    -- 元のサイズに戻す
    marker_colors    = extend_back(marker_colors, MARKER_MAX_COUNT - #marker_colors, 0xffffff)
    marker_alphas    = extend_back(marker_alphas, MARKER_MAX_COUNT - #marker_alphas, 0)
    marker_positions = extend_back(marker_positions, MARKER_MAX_COUNT - #marker_positions, 0)
    marker_midpoints = extend_back(marker_midpoints, MARKER_MAX_COUNT - #marker_midpoints, 50)

    local start_col = {}; local start_pos = {};
    local stop_col = {}; local stop_pos = {};
    local mid = {};
    for i = 1, MARKER_MAX_COUNT do
        -- Start Color & Position
        local start_rgb = norm_color(marker_colors[i])
        start_col[#start_col + 1] = start_rgb[1]
        start_col[#start_col + 1] = start_rgb[2]
        start_col[#start_col + 1] = start_rgb[3]
        start_col[#start_col + 1] = (100 - marker_alphas[i]) / 100
        start_pos[#start_pos + 1] = marker_positions[i] / 100

        -- Midpoint
        mid[#mid + 1] = marker_midpoints[i] / 100

        -- Stop Color & Position (Next marker)
        local next_i = i + 1
        if next_i > MARKER_MAX_COUNT then next_i = MARKER_MAX_COUNT end

        local stop_rgb = norm_color(marker_colors[next_i])
        stop_col[#stop_col + 1] = stop_rgb[1]
        stop_col[#stop_col + 1] = stop_rgb[2]
        stop_col[#stop_col + 1] = stop_rgb[3]
        stop_col[#stop_col + 1] = (100 - marker_alphas[next_i]) / 100
        stop_pos[#stop_pos + 1] = marker_positions[next_i] / 100
    end

    local pos_and_mid = {}
    for i = 1, MARKER_MAX_COUNT do
        pos_and_mid[#pos_and_mid + 1] = start_pos[i]
        pos_and_mid[#pos_and_mid + 1] = stop_pos[i]
        pos_and_mid[#pos_and_mid + 1] = mid[i]
        pos_and_mid[#pos_and_mid + 1] = 0.0  -- パディング
    end

    local packed = merge(
        {color_space},
        {interp_dir},
        {blur_width / 100},
        {marker_count},
        start_col,
        stop_col,
        pos_and_mid
    )

    return packed
end

local function rotate(deg)
    local rad = math.rad(deg)
    return {math.cos(rad), -math.sin(rad),
            math.sin(rad),  math.cos(rad)}
end

local constants = pack(colors, alphas, positions, midpoints, color_space, interp_dir, blur_width, marker_num)
local PAD = 0.0

local n = obj.setanchor("track", 0, "line")
local center_x = obj.track0
local center_y = obj.track1
local m00, m01, m10, m11 = unpack(rotate(angle))
local cache_name = "orig_img_"..tostring(obj.id)

obj.copybuffer("cache:"..cache_name, "object")
obj.setoption("drawtarget", "tempbuffer", obj.w, obj.h)
obj.draw()

obj.pixelshader("psmain", "object", {"object"},
    {
        obj.w, obj.h, center_x, center_y,
        radius, gradient_type, is_fit, PAD,
        m00, m01, PAD, PAD,
        m10, m11, PAD, PAD,
        unpack(constants),
    },
    "copy"
)

obj.setoption("blend", blend_mode)
obj.draw(0.0, 0.0, 0.0, 1.0, intensity / 100.0)
obj.copybuffer("obj", "tmp")
obj.setoption("blend", 0)

obj.pixelshader("mask", "object", {"cache:"..cache_name}, {}, "mask")

@GradientMap
--filter
--label:色調整
--information:Gradient Map for AviUtl2 v1.0.0 by azurite
--track@intensity:強さ,0,100,100,0.01
--select@luma_mode:ルーマ=0,Rec. 601=0,Rec. 709=1
--select@blend_mode:合成モード=0,通常=0,加算=1,減算=2,乗算=3,スクリーン=4,オーバーレイ=5,比較(明)=6
--group:色,false
--color@col1:色1,0x000000
--color@col2:色2,0xffffff
--color@col3:色3,0xffffff
--color@col4:色4,0xffffff
--color@col5:色5,0xffffff
--color@col6:色6,0xffffff
--color@col7:色7,0xffffff
--color@col8:色8,0xffffff
--color@col9:色9,0xffffff
--color@col10:色10,0xffffff
--color@col11:色11,0xffffff
--color@col12:色12,0xffffff
--color@col13:色13,0xffffff
--color@col14:色14,0xffffff
--color@col15:色15,0xffffff
--color@col16:色16,0xffffff
--color@col17:色17,0xffffff
--color@col18:色18,0xffffff
--color@col19:色19,0xffffff
--color@col20:色20,0xffffff
--color@col21:色21,0xffffff
--color@col22:色22,0xffffff
--color@col23:色23,0xffffff
--color@col24:色24,0xffffff
--color@col25:色25,0xffffff
--color@col26:色26,0xffffff
--color@col27:色27,0xffffff
--color@col28:色28,0xffffff
--color@col29:色29,0xffffff
--color@col30:色30,0xffffff
--group
--group:透明度,false
--track@alpha1:透明度1,0,100,0,0.01
--track@alpha2:透明度2,0,100,0,0.01
--track@alpha3:透明度3,0,100,0,0.01
--track@alpha4:透明度4,0,100,0,0.01
--track@alpha5:透明度5,0,100,0,0.01
--track@alpha6:透明度6,0,100,0,0.01
--track@alpha7:透明度7,0,100,0,0.01
--track@alpha8:透明度8,0,100,0,0.01
--track@alpha9:透明度9,0,100,0,0.01
--track@alpha10:透明度10,0,100,0,0.01
--track@alpha11:透明度11,0,100,0,0.01
--track@alpha12:透明度12,0,100,0,0.01
--track@alpha13:透明度13,0,100,0,0.01
--track@alpha14:透明度14,0,100,0,0.01
--track@alpha15:透明度15,0,100,0,0.01
--track@alpha16:透明度16,0,100,0,0.01
--track@alpha17:透明度17,0,100,0,0.01
--track@alpha18:透明度18,0,100,0,0.01
--track@alpha19:透明度19,0,100,0,0.01
--track@alpha20:透明度20,0,100,0,0.01
--track@alpha21:透明度21,0,100,0,0.01
--track@alpha22:透明度22,0,100,0,0.01
--track@alpha23:透明度23,0,100,0,0.01
--track@alpha24:透明度24,0,100,0,0.01
--track@alpha25:透明度25,0,100,0,0.01
--track@alpha26:透明度26,0,100,0,0.01
--track@alpha27:透明度27,0,100,0,0.01
--track@alpha28:透明度28,0,100,0,0.01
--track@alpha29:透明度29,0,100,0,0.01
--track@alpha30:透明度30,0,100,0,0.01
--group
--group:位置,false
--track@pos1:位置1,0,100,0,0.01
--track@pos2:位置2,0,100,100,0.01
--track@pos3:位置3,0,100,0,0.01
--track@pos4:位置4,0,100,0,0.01
--track@pos5:位置5,0,100,0,0.01
--track@pos6:位置6,0,100,0,0.01
--track@pos7:位置7,0,100,0,0.01
--track@pos8:位置8,0,100,0,0.01
--track@pos9:位置9,0,100,0,0.01
--track@pos10:位置10,0,100,0,0.01
--track@pos11:位置11,0,100,0,0.01
--track@pos12:位置12,0,100,0,0.01
--track@pos13:位置13,0,100,0,0.01
--track@pos14:位置14,0,100,0,0.01
--track@pos15:位置15,0,100,0,0.01
--track@pos16:位置16,0,100,0,0.01
--track@pos17:位置17,0,100,0,0.01
--track@pos18:位置18,0,100,0,0.01
--track@pos19:位置19,0,100,0,0.01
--track@pos20:位置20,0,100,0,0.01
--track@pos21:位置21,0,100,0,0.01
--track@pos22:位置22,0,100,0,0.01
--track@pos23:位置23,0,100,0,0.01
--track@pos24:位置24,0,100,0,0.01
--track@pos25:位置25,0,100,0,0.01
--track@pos26:位置26,0,100,0,0.01
--track@pos27:位置27,0,100,0,0.01
--track@pos28:位置28,0,100,0,0.01
--track@pos29:位置29,0,100,0,0.01
--track@pos30:位置30,0,100,0,0.01
--group
--group:中間点,false
--track@midpoint1:中間点1,0,100,50,0.01
--track@midpoint2:中間点2,0,100,50,0.01
--track@midpoint3:中間点3,0,100,50,0.01
--track@midpoint4:中間点4,0,100,50,0.01
--track@midpoint5:中間点5,0,100,50,0.01
--track@midpoint6:中間点6,0,100,50,0.01
--track@midpoint7:中間点7,0,100,50,0.01
--track@midpoint8:中間点8,0,100,50,0.01
--track@midpoint9:中間点9,0,100,50,0.01
--track@midpoint10:中間点10,0,100,50,0.01
--track@midpoint11:中間点11,0,100,50,0.01
--track@midpoint12:中間点12,0,100,50,0.01
--track@midpoint13:中間点13,0,100,50,0.01
--track@midpoint14:中間点14,0,100,50,0.01
--track@midpoint15:中間点15,0,100,50,0.01
--track@midpoint16:中間点16,0,100,50,0.01
--track@midpoint17:中間点17,0,100,50,0.01
--track@midpoint18:中間点18,0,100,50,0.01
--track@midpoint19:中間点19,0,100,50,0.01
--track@midpoint20:中間点20,0,100,50,0.01
--track@midpoint21:中間点21,0,100,50,0.01
--track@midpoint22:中間点22,0,100,50,0.01
--track@midpoint23:中間点23,0,100,50,0.01
--track@midpoint24:中間点24,0,100,50,0.01
--track@midpoint25:中間点25,0,100,50,0.01
--track@midpoint26:中間点26,0,100,50,0.01
--track@midpoint27:中間点27,0,100,50,0.01
--track@midpoint28:中間点28,0,100,50,0.01
--track@midpoint29:中間点29,0,100,50,0.01
--group
--group:その他,false
--track@blur_width:ぼかし幅,0,100,100,1
--select@color_space:色空間=0,sRGB=0,Linear sRGB=1,HSV=2,HSL=3,L*a*b=4,LCh=5,Oklab=6,Oklch=7
--select@interp_dir:補間経路=0,短経路=0,長経路=1
--track@marker_num:マーカー数,2,30,2,1
--group

--[[pixelshader@psmain:
#define PI 3.14159265358979323846
#define TAU (2.0 * PI)

#define SATURATION_THRESHOLD 0
#define CHROMA_THRESHOLD 0.02  // 無彩色か判定するのに使う誤差を考慮した閾値

static const float3 D65_WHITE = float3(0.95047, 1.0, 1.08883);
static const float3 D50_WHITE = float3(0.96422, 1.0, 0.82521);

float mod(float x, float y) {
    return x - y * floor(x / y);
}

float alpha_mix(float alpha1, float alpha2, float t) {
    return clamp(lerp(alpha1, alpha2, t), 0.0, 1.0);
}

// ----------------------------------------------------------------------------
// linear sRGB
// ----------------------------------------------------------------------------
// 参考: https://w.wiki/DBwx
float gamma_decode(float x) {
    return x <= 0.04045 ? x / 12.92 : pow(abs((x + 0.055) / 1.055), 2.4);
}

float3 srgb2linear(float3 x) {
    return float3(gamma_decode(x.r), gamma_decode(x.g), gamma_decode(x.b));
    //return pow(abs(x), float3(2.2));  // 近似
}

// 参考: https://w.wiki/DBx3
float gamma_encode(float x) {
    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(abs(x), 1.0 / 2.4) - 0.055;
}

float3 linear2srgb(float3 x) {
    return float3(gamma_encode(x.r), gamma_encode(x.g), gamma_encode(x.b));
    //return pow(abs(x), float3(1.0 / 2.2));  // 近似
}

// ----------------------------------------------------------------------------
// HSV
// ----------------------------------------------------------------------------
// 参考: https://w.wiki/DD6A
float3 srgb2hsv(float3 rgb) {
    float max_val = max(rgb.r, max(rgb.g, rgb.b));
    float min_val = min(rgb.r, min(rgb.g, rgb.b));
    float chroma = max_val - min_val;

    float hue = 0;
    float saturation = 0;

    if (chroma == 0) hue = 0;
    else if (max_val == rgb.r) hue = mod((rgb.g - rgb.b) / chroma, 6.0);
    else if (max_val == rgb.g) hue = (rgb.b - rgb.r) / chroma + 2.0;
    else hue = (rgb.r - rgb.g) / chroma + 4.0;
    hue *= 60.0;

    if (max_val == 0) saturation = 0;
    else saturation = chroma / max_val;

    return float3(radians(hue), saturation, max_val);
}

// 参考: https://w.wiki/DD66
float hsv2srgb_f(float3 hsv, float n) {
    float k = mod((n + degrees(hsv.x) / 60.0), 6.0);
    return hsv.z - hsv.z * hsv.y * max(0.0, min(k, min(4.0 - k, 1.0)));
}
float3 hsv2srgb(float3 hsv) {
    return float3(
        hsv2srgb_f(hsv, 5.0),
        hsv2srgb_f(hsv, 3.0),
        hsv2srgb_f(hsv, 1.0)
    );
}

// ----------------------------------------------------------------------------
// HSL
// ----------------------------------------------------------------------------
// 参考: https://w.wiki/DD6A
float3 srgb2hsl(float3 rgb) {
    float max_val = max(rgb.r, max(rgb.g, rgb.b));
    float min_val = min(rgb.r, min(rgb.g, rgb.b));
    float chroma = max_val - min_val;

    float hue = 0;
    if (chroma == 0) hue = 0;
    else if (max_val == rgb.r) hue = mod((rgb.g - rgb.b) / chroma, 6.0);
    else if (max_val == rgb.g) hue = (rgb.b - rgb.r) / chroma + 2.0;
    else hue = (rgb.r - rgb.g) / chroma + 4.0;
    hue *= 60.0;

    float lightness = (max_val + min_val) / 2.0;

    float saturation = 0.0;
    if (lightness != 1.0 && lightness != 0.0) {
        saturation = chroma / (1.0 - abs(2.0 * lightness - 1.0));
    }
    return float3 (radians(hue), saturation, lightness);
}

// 参考: https://w.wiki/DD6D
float hsl2rgb_f(float3 hsl, float n) {
    float k = mod((n + degrees(hsl.x) / 30.0), 12.0);
    float a = hsl.y * min(hsl.z, 1.0 - hsl.z);
    return hsl.z - a * max(-1.0, min(k - 3.0, min(9.0 - k, 1.0)));
}

float3 hsl2srgb(float3 hsl) {
    return float3(
        hsl2rgb_f(hsl, 0.0),
        hsl2rgb_f(hsl, 8.0),
        hsl2rgb_f(hsl, 4.0)
    );
}

float hue_mix(float hue1, float hue2, float t, int interp_dir) {
    float diff = hue2 - hue1;
    switch (interp_dir) {
    case 0:
        if (diff > PI) hue1 += TAU;
        else if (diff < -PI) hue2 += TAU;
        break;
    case 1:
        if (0.0 < diff && diff < PI) hue1 += TAU;
        else if (-PI < diff && diff <= 0.0) hue2 += TAU;
        break;
    }
    float angle = lerp(hue1, hue2, t);
    return mod(mod(angle, TAU) + TAU, TAU);
}

// 各色が無彩色かどうかに基づいてHueを調整し混合する
float adjust_and_mix_hue(float h1, float h2, bool has_valid_hue1, bool has_valid_hue2, float t, int interp_dir) {
    if (has_valid_hue1 && !has_valid_hue2) {
        h2 = h1;
    } else if (!has_valid_hue1 && has_valid_hue2) {
        h1 = h2;
    } else if (!has_valid_hue1 && !has_valid_hue2) {
        h1 = 0.0;
        h2 = 0.0;
    }
    return hue_mix(h1, h2, t, interp_dir);
}

// HSLも同じ補間を行う
float3 hsv_mix(float3 a, float3 b, float x, int interp_dir) {
    bool has_valid_hue1 = a.y > SATURATION_THRESHOLD;
    bool has_valid_hue2 = b.y > SATURATION_THRESHOLD;
    float hue = adjust_and_mix_hue(a.x, b.x, has_valid_hue1, has_valid_hue2, x, interp_dir);
    float3 hsv = float3(hue, lerp(a.yz, b.yz, x));
    return hsv;
}

// ----------------------------------------------------------------------------
// XYZ
// ----------------------------------------------------------------------------
// 参考: http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html
float3 linear2d50xyz(float3 linear_rgb) {
    float x = (0.4360747 * linear_rgb.r + 0.3850649 * linear_rgb.g + 0.1430804 * linear_rgb.b);
    float y = (0.2225045 * linear_rgb.r + 0.7168786 * linear_rgb.g + 0.0606169 * linear_rgb.b);
    float z = (0.0139322 * linear_rgb.r + 0.0971045 * linear_rgb.g + 0.7141733 * linear_rgb.b);
    return float3(x, y, z);
}

float3 d50xyz2linear(float3 xyz) {
    float r = (xyz.x *  3.1338561 + xyz.y * -1.6168667 + xyz.z * -0.4906146);
    float g = (xyz.x * -0.9787684 + xyz.y *  1.9161415 + xyz.z *  0.0334540);
    float b = (xyz.x *  0.0719453 + xyz.y * -0.2289914 + xyz.z *  1.4052427);
    return float3(r, g, b);
}

float3 linear2d65xyz(float3 linear_rgb) {
    float x = (0.4124564 * linear_rgb.r + 0.3575761 * linear_rgb.g + 0.1804375 * linear_rgb.b);
    float y = (0.2126729 * linear_rgb.r + 0.7151522 * linear_rgb.g + 0.0721750 * linear_rgb.b);
    float z = (0.0193339 * linear_rgb.r + 0.1191920 * linear_rgb.g + 0.9503041 * linear_rgb.b);
    return float3(x, y, z);
}

float3 d65xyz2linear(float3 xyz) {
    float r = (xyz.x *  3.2404542 + xyz.y * -1.5371385 + xyz.z * -0.4985314);
    float g = (xyz.x * -0.9692660 + xyz.y *  1.8760108 + xyz.z *  0.0415560);
    float b = (xyz.x *  0.0556434 + xyz.y * -0.2040259 + xyz.z *  1.0572252);
    return float3(r, g, b);
}

// ----------------------------------------------------------------------------
// CIELAB
// ----------------------------------------------------------------------------
// 参考: http://www.brucelindbloom.com/Eqn_XYZ_to_Lab.html
float xyz2lab_f(float x) {
    return x > 0.008856 ? pow(abs(x), 0.333333333) : (903.3 * x + 16.0) / 116.0;
}

float3 d50xyz2lab(float3 xyz) {
    float3 xyz_scaled = xyz / D50_WHITE;
    xyz_scaled = float3(
        xyz2lab_f(xyz_scaled.x),
        xyz2lab_f(xyz_scaled.y),
        xyz2lab_f(xyz_scaled.z)
    );
    return float3(
        (116.0 * xyz_scaled.y) - 16.0,
         500.0 * (xyz_scaled.x - xyz_scaled.y),
         200.0 * (xyz_scaled.y - xyz_scaled.z)
    );
}

float3 d65xyz2lab(float3 xyz) {
    float3 xyz_scaled = xyz / D65_WHITE;
    xyz_scaled = float3(
        xyz2lab_f(xyz_scaled.x),
        xyz2lab_f(xyz_scaled.y),
        xyz2lab_f(xyz_scaled.z)
    );
    return float3(
        (116.0 * xyz_scaled.y) - 16.0,
         500.0 * (xyz_scaled.x - xyz_scaled.y),
         200.0 * (xyz_scaled.y - xyz_scaled.z)
    );
}

// 参考: http://www.brucelindbloom.com/Eqn_Lab_to_XYZ.html
float lab2xyz_f(float x) {
    return pow(abs(x), 3.0) > 0.008856 ? pow(abs(x), 3.0) : (116.0 * x - 16.0) / 903.3;
}

float3 lab2d50xyz(float3 lab) {
    float f = (lab.x + 16.0) / 116.0;
    float y = lab.x > 0.008856 * 903.3 ? pow(abs((lab.x + 16.0) / 116.0), 3.0) : lab.x / 903.3;
    return D50_WHITE * float3(
        lab2xyz_f(f + lab.y / 500.0),
        y,
        lab2xyz_f(f - lab.z / 200.0)
    );
}

float3 lab2d65xyz(float3 lab) {
    float f = (lab.x + 16.0) / 116.0;
    float y = lab.x > 0.008856 * 903.3 ? pow(abs((lab.x + 16.0) / 116.0), 3.0) : lab.x / 903.3;
    return D65_WHITE * float3(
        lab2xyz_f(f + lab.y / 500.0),
        y,
        lab2xyz_f(f - lab.z / 200.0)
    );
}

float3 linear2d50lab(float3 linear_rgb) {
    float3 xyz = linear2d50xyz(linear_rgb);
    return d50xyz2lab(xyz);
}

float3 d50lab2linear(float3 lab) {
    float3 xyz = lab2d50xyz(lab);
    return d50xyz2linear(xyz);
}

float3 linear2d65lab(float3 linear_rgb) {
    float3 xyz = linear2d65xyz(linear_rgb);
    return d65xyz2lab(xyz);
}

float3 d65lab2linear(float3 lab) {
    float3 xyz = lab2d65xyz(lab);
    return d65xyz2linear(xyz);
}

// ----------------------------------------------------------------------------
// CIELCH
// ----------------------------------------------------------------------------
// 参考: http://www.brucelindbloom.com/Eqn_Lab_to_LCH.html
float3 lab2lch(float3 lab) {
    float chroma = length(float2(lab.y, lab.z));
    float hue = 0.0;
    // 無彩色でない場合のみHueを計算
    if (chroma > CHROMA_THRESHOLD) {
        hue = atan2(lab.z, lab.y);
        hue = hue < 0.0 ? hue + TAU : hue;
    }
    return float3(
        lab.x,
        chroma,
        hue
    );
}

// 参考: http://www.brucelindbloom.com/Eqn_LCH_to_Lab.html
float3 lch2lab(float3 lch) {
    return float3(
        lch.x,
        lch.y * cos(lch.z),
        lch.y * sin(lch.z)
    );
}

float3 linear2d50lch(in float3 linear_rgb) {
    float3 xyz = linear2d50xyz(linear_rgb);
    float3 lab = d50xyz2lab(xyz);
    return lab2lch(lab);
}

float3 d50lch2linear(in float3 lch) {
    float3 lab = lch2lab(lch);
    float3 xyz = lab2d50xyz(lab);
    return d50xyz2linear(xyz);
}

float3 linear2d65lch(in float3 linear_rgb) {
    float3 xyz = linear2d65xyz(linear_rgb);
    float3 lab = d65xyz2lab(xyz);
    return lab2lch(lab);
}

float3 d65lch2linear(in float3 lch) {
    float3 lab = lch2lab(lch);
    float3 xyz = lab2d65xyz(lab);
    return d65xyz2linear(xyz);
}

float3 lch_mix(float3 a, float3 b, float x, int interp_dir) {
    float lightness = lerp(a.x, b.x, x);
    float chroma = lerp(a.y, b.y, x);
    bool has_valid_hue1 = a.y > CHROMA_THRESHOLD;
    bool has_valid_hue2 = b.y > CHROMA_THRESHOLD;
    float hue = adjust_and_mix_hue(a.z, b.z, has_valid_hue1, has_valid_hue2, x, interp_dir);
    lightness = clamp(lightness, 0.0, 100.0);
    chroma = max(chroma, 0.0);
    return float3(lightness, chroma, hue);
}

// ----------------------------------------------------------------------------
// Oklab
// ----------------------------------------------------------------------------
float cbrt(float x) {
    return sign(x) * pow(abs(x), 1.0 / 3.0);
}

// 参考: https://bottosson.github.io/posts/oklab/#converting-from-linear-srgb-to-oklab
float3 linear2oklab(float3 linear_rgb) {
    float l = 0.4122214708 * linear_rgb.r + 0.5363325363 * linear_rgb.g + 0.0514459929 * linear_rgb.b;
	float m = 0.2119034982 * linear_rgb.r + 0.6806995451 * linear_rgb.g + 0.1073969566 * linear_rgb.b;
	float s = 0.0883024619 * linear_rgb.r + 0.2817188376 * linear_rgb.g + 0.6299787005 * linear_rgb.b;

    float l_ = cbrt(l);
    float m_ = cbrt(m);
    float s_ = cbrt(s);

    return float3(
        0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
        1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
        0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
    );
}

// 参考: https://bottosson.github.io/posts/oklab/#converting-from-linear-srgb-to-oklab
float3 oklab2linear(float3 oklab) {
    float l_ = oklab.x + 0.3963377774 * oklab.y + 0.2158037573 * oklab.z;
    float m_ = oklab.x - 0.1055613458 * oklab.y - 0.0638541728 * oklab.z;
    float s_ = oklab.x - 0.0894841775 * oklab.y - 1.2914855480 * oklab.z;

    float l = l_ * l_ * l_;
    float m = m_ * m_ * m_;
    float s = s_ * s_ * s_;

    return float3(
		 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
		-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
		-0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
    );
}

// ----------------------------------------------------------------------------
// Oklch
// ----------------------------------------------------------------------------
float3 linear2oklch(float3 linear_rgb) {
    float3 oklab = linear2oklab(linear_rgb);
    return lab2lch(oklab);
}

float3 oklch2linear(float3 oklch) {
    float3 oklab = lch2lab(oklch);
    return oklab2linear(oklab);
}
Texture2D<float4> src : register(t0);
SamplerState samp : register(s0);

static const int GRADIENT_MAX_COUNT = 30;
cbuffer constant0 : register(b0) {
    float luma_mode;
    float3 pad;
    float color_space;
    float interp_dir;
    float gradient_w;
    float gradient_count;  // 実際のグラデーションの数
    float4 start_col[GRADIENT_MAX_COUNT];
    float4 stop_col[GRADIENT_MAX_COUNT];
    float4 pos_and_mid[GRADIENT_MAX_COUNT];
}

float4 blend_colors(float4 color1, float4 color2, float t, float color_space, int interp_dir)
{
    float3 col1 = color1.rgb;
    float3 col2 = color2.rgb;
    float alpha1 = color1.a;
    float alpha2 = color2.a;
    float3 result = float3(0.0, 0.0, 0.0);
    float mixed_alpha = max(alpha_mix(alpha1, alpha2, t), 1e-6);
    switch (color_space) {
        case 0:  // sRGB
        {
            float3 premulti_srgb1 = col1 * alpha1;
            float3 premulti_srgb2 = col2 * alpha2;
            float3 mixed_srgb = lerp(premulti_srgb1, premulti_srgb2, t);
            float3 unpremulti_srgb = mixed_srgb / mixed_alpha;
            result = unpremulti_srgb;
            break;
        }
        case 1:  // Linear sRGB
        {
            float3 premulti_linear1 = srgb2linear(col1) * alpha1;
            float3 premulti_linear2 = srgb2linear(col2) * alpha2;
            float3 mixed_linear = lerp(premulti_linear1, premulti_linear2, t);
            float3 unpremulti_linear = mixed_linear / mixed_alpha;
            result = linear2srgb(clamp(unpremulti_linear, 0.0, 1.0));
            break;
        }
        case 2:  // HSV
        {
            float3 hsv1 = srgb2hsv(col1);
            float3 hsv2 = srgb2hsv(col2);

            // 片方が透明であってもその色が持っているHueを維持してグラデーションを作るために、
            // アルファを掛ける前の彩度で無彩色かどうかを判定する
            bool has_valid_hue1 = hsv1.y > SATURATION_THRESHOLD;
            bool has_valid_hue2 = hsv2.y > SATURATION_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(hsv1.x, hsv2.x, has_valid_hue1, has_valid_hue2, t, interp_dir);

            // 彩度と明度はアルファを掛けた後で補間する
            float2 sv1 = hsv1.yz * alpha1;
            float2 sv2 = hsv2.yz * alpha2;
            float2 mixed_sv = lerp(sv1, sv2, t);
            mixed_sv /= mixed_alpha;

            // 結果の色を合成
            float3 result_hsv = float3(mixed_hue, mixed_sv);
            result = hsv2srgb(result_hsv);
            break;
        }
        case 3:  // HSL
        {
            float3 hsl1 = srgb2hsl(col1);
            float3 hsl2 = srgb2hsl(col2);

            bool has_valid_hue1 = hsl1.y > SATURATION_THRESHOLD;
            bool has_valid_hue2 = hsl2.y > SATURATION_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(hsl1.x, hsl2.x, has_valid_hue1, has_valid_hue2, t, interp_dir);

            float2 sl1 = hsl1.yz * alpha1;
            float2 sl2 = hsl2.yz * alpha2;
            float2 mixed_sl = lerp(sl1, sl2, t);
            mixed_sl /= mixed_alpha;

            float3 result_hsl = float3(mixed_hue, mixed_sl);
            result = hsl2srgb(result_hsl);
            break;
        }
        case 4:  // L*a*b* (CIELAB)
        {
            // D50基準
            float3 lab1 = linear2d50lab(srgb2linear(col1));
            float3 lab2 = linear2d50lab(srgb2linear(col2));
            float3 premulti_lab1 = lab1 * alpha1;
            float3 premulti_lab2 = lab2 * alpha2;
            float3 mixed_lab = lerp(premulti_lab1, premulti_lab2, t);
            float3 unpremulti_lab = mixed_lab / mixed_alpha;
            result = linear2srgb(clamp(d50lab2linear(unpremulti_lab), 0.0, 1.0));
            break;
        }
        case 5:  // LCh
        {
            // D50基準
            float3 lch1 = linear2d50lch(srgb2linear(col1));
            float3 lch2 = linear2d50lch(srgb2linear(col2));

            bool has_valid_hue1 = lch1.y > CHROMA_THRESHOLD;
            bool has_valid_hue2 = lch2.y > CHROMA_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(lch1.z, lch2.z, has_valid_hue1, has_valid_hue2, t, interp_dir);

            float2 lc1 = lch1.xy * alpha1;
            float2 lc2 = lch2.xy * alpha2;
            float2 mixed_lc = lerp(lc1, lc2, t);
            mixed_lc = mixed_lc / mixed_alpha;

            mixed_lc.x = clamp(mixed_lc.x, 0.0, 100.0);
            mixed_lc.y = max(mixed_lc.y, 0.0);

            float3 result_lch = float3(mixed_lc.x, mixed_lc.y, mixed_hue);
            result = linear2srgb(clamp(d50lch2linear(result_lch), 0.0, 1.0));
            break;
        }
        case 6:  // Oklab
        {
            float3 oklab1 = linear2oklab(srgb2linear(col1));
            float3 oklab2 = linear2oklab(srgb2linear(col2));
            float3 premulti_oklab1 = oklab1 * alpha1;
            float3 premulti_oklab2 = oklab2 * alpha2;
            float3 mixed_oklab = lerp(premulti_oklab1, premulti_oklab2, t);
            float3 unpremulti_oklab = mixed_oklab / mixed_alpha;
            result = linear2srgb(clamp(oklab2linear(unpremulti_oklab), 0.0, 1.0));
            break;
        }
        case 7:  // OkLCh
        {
            float3 oklch1 = linear2oklch(srgb2linear(col1));
            float3 oklch2 = linear2oklch(srgb2linear(col2));

            bool has_valid_hue1 = oklch1.y > CHROMA_THRESHOLD;
            bool has_valid_hue2 = oklch2.y > CHROMA_THRESHOLD;
            float mixed_hue = adjust_and_mix_hue(oklch1.z, oklch2.z, has_valid_hue1, has_valid_hue2, t, interp_dir);

            float2 lc1 = oklch1.xy * alpha1;
            float2 lc2 = oklch2.xy * alpha2;
            float2 mixed_lc = lerp(lc1, lc2, t);
            mixed_lc = mixed_lc / mixed_alpha;

            mixed_lc.x = clamp(mixed_lc.x, 0.0, 1.0);
            mixed_lc.y = max(mixed_lc.y, 0.0);

            float3 result_oklch = float3(mixed_lc.x, mixed_lc.y, mixed_hue);
            result = linear2srgb(clamp(oklch2linear(result_oklch), 0.0, 1.0));
            break;
        }
    }
    return float4(result * mixed_alpha, mixed_alpha);
}

float4 makeGradient(float4 col1, float4 col2, float t, float mid, float width, float color_space, int interp_dir)
{
    float half_width = width * 0.5;

    float lower = mid - half_width;
    float upper = mid + half_width;

    t = smoothstep(lower, upper, t);

    float4 result = blend_colors(col1, col2, t, color_space, interp_dir);
    return result;
}

float4 unpremulti(float4 col)
{
    return col.a > 0.0 ? float4(col.rgb / col.a, 1.0) : float4(col.rgb, 1.0);
}

float4 psmain(float4 pos : SV_Position, float2 uv : TEXCOORD) : SV_Target {
    float4 tex_col = src.Sample(samp, uv);

    // アンチエイリアス等でアルファが1未満の場合、RGBがPre-multipliedだと輝度が低く判定されてしまうため、
    // アルファで除算して元の色の輝度を取得する
    float3 unpremul_col = unpremulti(tex_col).rgb;

    float luma;
    switch (luma_mode) {
        case 0:  // Rec. 601
        {
            luma = dot(unpremul_col, float3(0.299, 0.587, 0.114));
            break;
        }
        case 1:  // Rec. 701
        {
            luma = dot(unpremul_col, float3(0.2126, 0.7152, 0.0722));
            break;
        }
        default:
        {
            luma = dot(unpremul_col, float3(0.299, 0.587, 0.114));
            break;
        }
    }

    float x = luma;

    int safe_count = min(gradient_count, GRADIENT_MAX_COUNT);
    float4 out_col = (x <= pos_and_mid[0].x) ? start_col[0] : start_col[safe_count - 1];
    out_col.rgb *= out_col.a;
    for (int i = 0; i < safe_count; i++) {
        float p_curr = pos_and_mid[i].x;
        float p_next = pos_and_mid[i].y;

        // x が現在の区間内にある場合
        if (x >= p_curr && x < p_next) {
            float dist = p_next - p_curr;

            float t = (x - p_curr) / dist;

            out_col = makeGradient(start_col[i], stop_col[i], t, pos_and_mid[i].z, gradient_w, color_space, interp_dir);
            break;
        }
    }

    return out_col;
}

]]

--[[pixelshader@mask:
Texture2D<float4> src : register(t0);
float4 mask(float4 pos : SV_Position) : SV_Target {
    return src.Load(int3(pos.xy, 0));
}
]]

local colors = {col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11, col12, col13, col14, col15, col16, col17, col18, col19, col20, col21, col22, col23, col24, col25, col26, col27, col28, col29, col30}
local alphas = {alpha1, alpha2, alpha3, alpha4, alpha5, alpha6, alpha7, alpha8, alpha9, alpha10, alpha11, alpha12, alpha13, alpha14, alpha15, alpha16, alpha17, alpha18, alpha19, alpha20, alpha21, alpha22, alpha23, alpha24, alpha25, alpha26, alpha27, alpha28, alpha29, alpha30}
local positions = {pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9, pos10, pos11, pos12, pos13, pos14, pos15, pos16, pos17, pos18, pos19, pos20, pos21, pos22, pos23, pos24, pos25, pos26, pos27, pos28, pos29, pos30}
local midpoints = {midpoint1, midpoint2, midpoint3, midpoint4, midpoint5, midpoint6, midpoint7, midpoint8, midpoint9, midpoint10, midpoint11, midpoint12, midpoint13, midpoint14, midpoint15, midpoint16, midpoint17, midpoint18, midpoint19, midpoint20, midpoint21, midpoint22, midpoint23, midpoint24, midpoint25, midpoint26, midpoint27, midpoint28, midpoint29, 0}

-- 色を正規化する
local function norm_color(color)
    local r, g, b = RGB(color)
    return {r / 255, g / 255, b / 255}
end

-- 非シーケンス、nil以外の値を渡された順番で1つのシーケンスにマージして返す
local function merge(...)
	local function flatten(v, res)
	    res = res or {}
	    if type(v) ~= "table" then
            res[#res + 1] = v
            return res
        end
	    for _, x in ipairs(v) do
            flatten(x, res)
        end
	    return res
	end
	local t = {...}
	return flatten(t)
end

-- テーブルの後ろ側に任意の長さだけ拡張する
local function extend_back(t, n, v)
	if type(v) == "nil" or type(v) == "table" then
		return
	end
	for i = 1, n do
		t[#t + 1] = v
	end
	return t
end

-- テーブルから指定した範囲を切り出す
local function slice(t, first, last)
    local res = {}
    for i = first, last do
        res[#res + 1] = t[i]
    end
    return res
end

-- 並び替え
local function reorder(t, idx)
    local r = {}
    for i, j in ipairs(idx) do
        r[i] = t[j]
    end
    return r
end

-- HLSL のコンスタントバッファーに渡すために変数を詰める
local function pack(colors, alphas, positions, midpoints, color_space, interp_dir, blur_width, marker_num)
    assert(#colors == #alphas and #alphas == #positions and #positions == #midpoints, "Marker arrays must have the same length")

    local marker_count = marker_num
    local MARKER_MAX_COUNT = #colors

    -- マーカー数分だけ切り出す
    local marker_colors = slice(colors, 1, marker_count)
    local marker_alphas = slice(alphas, 1, marker_count)
    local marker_positions = slice(positions, 1, marker_count)
    local marker_midpoints = slice(midpoints, 1, marker_count)

    -- インデックス配列
    local idx = {}
    for i = 1, marker_count do
        idx[i] = i
    end

    table.sort(idx, function(a, b)
        local pa, pb = marker_positions[a], marker_positions[b]
        if pa ~= pb then
            return pa < pb
        end
        return a < b   -- 同じ positions の場合は若いインデックス優先
    end)

    -- 並び替え
    marker_colors   = reorder(marker_colors, idx)
    marker_alphas   = reorder(marker_alphas, idx)
    marker_positions = reorder(marker_positions, idx)
    marker_midpoints = reorder(marker_midpoints, idx)

    -- 元のサイズに戻す
    marker_colors    = extend_back(marker_colors, MARKER_MAX_COUNT - #marker_colors, 0xffffff)
    marker_alphas    = extend_back(marker_alphas, MARKER_MAX_COUNT - #marker_alphas, 0)
    marker_positions = extend_back(marker_positions, MARKER_MAX_COUNT - #marker_positions, 0)
    marker_midpoints = extend_back(marker_midpoints, MARKER_MAX_COUNT - #marker_midpoints, 50)

    local start_col = {}; local start_pos = {};
    local stop_col = {}; local stop_pos = {};
    local mid = {};
    for i = 1, MARKER_MAX_COUNT do
        -- Start Color & Position
        local start_rgb = norm_color(marker_colors[i])
        start_col[#start_col + 1] = start_rgb[1]
        start_col[#start_col + 1] = start_rgb[2]
        start_col[#start_col + 1] = start_rgb[3]
        start_col[#start_col + 1] = (100 - marker_alphas[i]) / 100
        start_pos[#start_pos + 1] = marker_positions[i] / 100

        -- Midpoint
        mid[#mid + 1] = marker_midpoints[i] / 100

        -- Stop Color & Position (Next marker)
        local next_i = i + 1
        if next_i > MARKER_MAX_COUNT then next_i = MARKER_MAX_COUNT end

        local stop_rgb = norm_color(marker_colors[next_i])
        stop_col[#stop_col + 1] = stop_rgb[1]
        stop_col[#stop_col + 1] = stop_rgb[2]
        stop_col[#stop_col + 1] = stop_rgb[3]
        stop_col[#stop_col + 1] = (100 - marker_alphas[next_i]) / 100
        stop_pos[#stop_pos + 1] = marker_positions[next_i] / 100
    end

    local pos_and_mid = {}
    for i = 1, MARKER_MAX_COUNT do
        pos_and_mid[#pos_and_mid + 1] = start_pos[i]
        pos_and_mid[#pos_and_mid + 1] = stop_pos[i]
        pos_and_mid[#pos_and_mid + 1] = mid[i]
        pos_and_mid[#pos_and_mid + 1] = 0.0  -- パディング
    end

    local packed = merge(
        {color_space},
        {interp_dir},
        {blur_width / 100},
        {marker_count},
        start_col,
        stop_col,
        pos_and_mid
    )

    return packed
end

local function rotate(deg)
    local rad = math.rad(deg)
    return {math.cos(rad), -math.sin(rad),
            math.sin(rad),  math.cos(rad)}
end

local constants = pack(colors, alphas, positions, midpoints, color_space, interp_dir, blur_width, marker_num)
local PAD = 0.0

local cache_name = "orig_img_"..tostring(obj.id)

obj.copybuffer("cache:"..cache_name, "object")
obj.setoption("drawtarget", "tempbuffer", obj.w, obj.h)
obj.draw()

obj.pixelshader("psmain", "object", {"object"},
    {
        luma_mode, PAD, PAD, PAD,
        unpack(constants),
    },
    "copy"
)

obj.setoption("blend", blend_mode)
obj.draw(0.0, 0.0, 0.0, 1.0, intensity / 100.0)
obj.copybuffer("obj", "tmp")
obj.setoption("blend", 0)

obj.pixelshader("mask", "object", {"cache:"..cache_name}, {}, "mask")

